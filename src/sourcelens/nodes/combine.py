# src/sourcelens/nodes/combine.py

"""Node responsible for combining generated tutorial components into final files."""

import logging
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Optional, TypeAlias

from sourcelens.nodes.base_node import BaseNode, SharedState
from sourcelens.utils.helpers import sanitize_filename

# --- Type Aliases ---
AbstractionsList: TypeAlias = list[dict[str, Any]]
RelationshipsDict: TypeAlias = dict[str, Any]
ChapterOrderList: TypeAlias = list[int]
ChapterContentList: TypeAlias = list[str]
ChapterFileData: TypeAlias = dict[str, Any]
DiagramMarkup: TypeAlias = str
SequenceDiagramsList: TypeAlias = list[DiagramMarkup]  # Type for list of sequence diagrams
DiagramConfigDict: TypeAlias = dict[str, Any]  # Type for diagram_generation config section
SequenceDiagramConfigDict: TypeAlias = dict[str, Any]  # Type for include_sequence_diagrams config

# Specific types for this node's prep/exec results
CombinePrepResult: TypeAlias = bool
CombineExecResult: TypeAlias = None

logger = logging.getLogger(__name__)


# --- Dataclasses ---
@dataclass(frozen=True)
class FooterInfo:
    """Encapsulates information needed to generate the file footer.

    Attributes:
        provider_name: Name of the LLM provider used.
        model_name: Name of the LLM model used.
        is_local: Flag indicating if the LLM is local.
        source_language: The language profile used for analysis.

    """

    provider_name: str
    model_name: str
    is_local: bool
    source_language: str

    def format_footer(self) -> str:
        """Generate the formatted footer string including all details.

        Returns:
            A formatted Markdown string for the file footer.

        """
        location = "(local)" if self.is_local else "(cloud)"
        repo_link = "https://github.com/darijo2yahoocom/sourceLensAI"
        return (
            f"\n\n---\n\n*Generated by [SourceLens AI]({repo_link}) "
            f"using LLM: `{self.provider_name}` {location} - model: `{self.model_name}` | "
            f"Language Profile: `{self.source_language}`*"
        )


@dataclass(frozen=True)
class IndexContext:
    """Encapsulates context needed to prepare the index file content.

    Attributes:
        project_name: The name of the project.
        relationships_data: Dictionary containing relationship summary and details.
        footer_info: FooterInfo dataclass instance.
        # --- Arguments with defaults MUST come after non-default arguments ---
        repo_url: The URL of the source GitHub repository, if applicable.
        local_dir: The path to the source local directory, if applicable.
        relationship_flowchart_markup: Mermaid markup for the relationship flowchart.
        class_diagram_markup: Mermaid markup for the class diagram.
        package_diagram_markup: Mermaid markup for the package diagram.
        sequence_diagrams_markup: List of Mermaid markups for sequence diagrams.
        chapter_files_data: List of dictionaries, each representing a chapter file.
        diagram_config: The 'diagram_generation' section from the configuration.
        # --- Derived fields (initialized in __post_init__) ---
        include_rel_flowchart: Flag to include the relationship flowchart.
        include_class_diag: Flag to include the class diagram.
        include_pkg_diag: Flag to include the package diagram.
        include_sequence_diagrams: Config dictionary for sequence diagrams.

    """

    # Arguments without defaults first
    project_name: str
    relationships_data: RelationshipsDict
    footer_info: FooterInfo

    # Arguments with defaults or Optional that can be None
    repo_url: Optional[str] = None
    local_dir: Optional[str] = None
    relationship_flowchart_markup: Optional[DiagramMarkup] = None
    class_diagram_markup: Optional[DiagramMarkup] = None
    package_diagram_markup: Optional[DiagramMarkup] = None
    sequence_diagrams_markup: Optional[SequenceDiagramsList] = None
    chapter_files_data: list[ChapterFileData] = field(default_factory=list)
    diagram_config: DiagramConfigDict = field(default_factory=dict)

    # Derived fields (can stay at the end as init=False)
    include_rel_flowchart: bool = field(init=False)
    include_class_diag: bool = field(init=False)
    include_pkg_diag: bool = field(init=False)
    include_sequence_diagrams: SequenceDiagramConfigDict = field(init=False)

    def __post_init__(self) -> None:
        """Set derived diagram flags after initialization."""
        # Use object.__setattr__ because the class is frozen
        object.__setattr__(
            self, "include_rel_flowchart", self.diagram_config.get("include_relationship_flowchart", False)
        )
        object.__setattr__(self, "include_class_diag", self.diagram_config.get("include_class_diagram", False))
        object.__setattr__(self, "include_pkg_diag", self.diagram_config.get("include_package_diagram", False))
        object.__setattr__(self, "include_sequence_diagrams", self.diagram_config.get("include_sequence_diagrams", {}))


class CombineTutorial(BaseNode):
    """Combine generated tutorial parts into final Markdown files.

    Reads processed data and diagram markups from shared state, assembles
    index.md and chapter files, adds attributions, and writes the tutorial structure.
    Includes logic to embed sequence diagrams if configured and available.
    """

    def _prepare_index_content(self, context: IndexContext) -> str:
        """Prepare the full Markdown content for the index.md file using context object.

        Includes logic to embed relationship, class, package, and sequence diagrams
        if they are enabled in the configuration and markup is available in the context.

        Args:
            context: An IndexContext object containing all necessary data and configuration flags.

        Returns:
            A string containing the complete Markdown content for index.md.

        """
        # Project Title and Summary
        summary_raw = context.relationships_data.get("summary", f"Tutorial for {context.project_name}.")
        summary = str(summary_raw or f"Tutorial for {context.project_name}.")
        index_content_parts: list[str] = [f"# Tutorial: {context.project_name}\n\n{summary}\n"]

        # Source Information
        source_info = ""
        if context.repo_url:
            source_info = f"**Source Repository:** [{context.repo_url}]({context.repo_url})"
        elif context.local_dir:
            try:
                # Attempt to resolve to an absolute path for clarity
                resolved_path = Path(context.local_dir).resolve(strict=True)
                source_info = f"**Source Directory:** `{resolved_path}`"
            except (OSError, ValueError) as e:
                logger.warning(
                    "Cannot resolve local directory path '%s': %s. Using original path.", context.local_dir, e
                )
                source_info = f"**Source Directory:** `{context.local_dir}`"
        if source_info:
            index_content_parts.append(f"{source_info}\n")

        diagram_format = context.diagram_config.get("format", "mermaid")  # Get format from config

        # Embed Relationship Flowchart
        if context.include_rel_flowchart:
            if context.relationship_flowchart_markup:
                index_content_parts.extend(
                    [
                        "## Abstraction Relationships\n",
                        f"```{diagram_format}\n{context.relationship_flowchart_markup}\n```\n",
                    ]
                )
                self._log_info("Embedding relationship flowchart into index.md.")
            else:
                self._log_warning("Relationship flowchart enabled but no markup found in shared state.")

        # Embed Class Diagram
        if context.include_class_diag:
            if context.class_diagram_markup:
                index_content_parts.extend(
                    [
                        "## Class Diagram\n",
                        f"```{diagram_format}\n{context.class_diagram_markup}\n```\n",
                    ]
                )
                self._log_info("Embedding class diagram into index.md.")
            else:
                self._log_warning("Class diagram enabled but no markup found in shared state.")

        # Embed Package Diagram
        if context.include_pkg_diag:
            if context.package_diagram_markup:
                index_content_parts.extend(
                    [
                        "## Package Dependencies\n",
                        f"```{diagram_format}\n{context.package_diagram_markup}\n```\n",
                    ]
                )
                self._log_info("Embedding package diagram into index.md.")
            else:
                self._log_warning("Package diagram enabled but no markup found in shared state.")

        # Embed Sequence Diagrams
        seq_config = context.include_sequence_diagrams  # Get the nested config dict
        # Check if sequence diagrams are enabled within their specific config
        if seq_config.get("enabled", False):
            # Check if diagrams should be embedded (vs. separate files)
            # Currently always embedding if enabled and present, separate file logic is in _write_output_files
            if context.sequence_diagrams_markup:
                index_content_parts.append("## Sequence Diagrams\n")
                scenarios_list = seq_config.get("scenarios", [])
                num_scenarios = len(scenarios_list)
                num_markups = len(context.sequence_diagrams_markup)

                if num_markups != num_scenarios and num_markups > 0:  # Log only if markups were generated
                    logger.warning(
                        "Mismatch between number of sequence diagram markups (%d) and configured scenarios (%d). "
                        "Displaying available diagrams.",
                        num_markups,
                        num_scenarios,
                    )

                for i, seq_markup in enumerate(context.sequence_diagrams_markup):
                    # Try to get scenario name, provide default if lists don't match or index out of bounds
                    scenario_name = scenarios_list[i] if i < num_scenarios else f"Sequence Diagram {i + 1}"
                    # Sanitize name for heading if needed, but display original if possible
                    safe_heading_name = scenario_name.replace("_", " ").capitalize()
                    index_content_parts.extend(
                        [
                            f"### Scenario: {safe_heading_name}\n",
                            f"```{diagram_format}\n{seq_markup}\n```\n",
                        ]
                    )
                self._log_info("Embedding %d sequence diagram(s) into index.md.", len(context.sequence_diagrams_markup))
            else:
                self._log_warning("Sequence diagrams enabled but no markup found in shared state.")

        # Chapters List
        index_content_parts.append("## Chapters\n")
        try:
            # Sort chapters based on the 'num' key assigned during generation
            sorted_chapters = sorted(context.chapter_files_data, key=lambda x: x.get("num", float("inf")))
        except TypeError:
            # Fallback if sorting fails (e.g., 'num' missing or not comparable)
            logger.warning("Cannot sort chapters based on 'num' key. Using original order.")
            sorted_chapters = context.chapter_files_data

        chapter_links: list[str] = []
        for ch_data in sorted_chapters:
            num = ch_data.get("num")
            name = ch_data.get("name")
            fname = ch_data.get("filename")
            # Ensure all parts needed for the link are valid
            if isinstance(num, int) and isinstance(name, str) and isinstance(fname, str):
                chapter_links.append(f"{num}. [{name}]({fname})")
            else:
                logger.warning("Skipping chapter link due to invalid data format: %s", ch_data)

        index_content_parts.append("\n".join(chapter_links))

        # Footer
        footer = context.footer_info.format_footer()
        index_content_parts.append(footer)  # Footer already contains necessary leading newlines

        self._log_info("Prepared index.md content string.")
        return "\n".join(index_content_parts)

    def _prepare_chapter_file_data(
        self,
        abstractions: AbstractionsList,
        chapter_order: ChapterOrderList,
        chapters_content: ChapterContentList,
        footer_info: FooterInfo,
    ) -> list[ChapterFileData]:
        """Prepare data structure for each chapter file, adding dynamic footer.

        Args:
            abstractions: List of identified abstraction dictionaries from analysis.
            chapter_order: Ordered list of abstraction indices representing chapter sequence.
            chapters_content: List of generated Markdown content strings for each chapter.
            footer_info: Dataclass containing LLM and source language details for the footer.

        Returns:
            A list of dictionaries, each representing a chapter file with its
            filename, content (including footer), name, abstraction index, and chapter number.

        """
        chapter_files_data: list[ChapterFileData] = []
        num_abstractions = len(abstractions)
        num_content_items = len(chapters_content)
        num_order_items = len(chapter_order)

        # Use the minimum length to avoid index errors if lists mismatch
        effective_chapter_count = min(num_order_items, num_content_items)
        if num_order_items != num_content_items:
            logger.warning(
                "Mismatch between chapter order length (%d) and chapter content count (%d). Processing %d chapters.",
                num_order_items,
                num_content_items,
                effective_chapter_count,
            )

        footer = footer_info.format_footer()
        for i in range(effective_chapter_count):
            abs_idx = chapter_order[i]
            # Validate abstraction index before accessing abstractions list
            if not (0 <= abs_idx < num_abstractions):
                logger.warning(
                    "Skipping chapter preparation: Invalid abstraction index %d found at order position %d.", abs_idx, i
                )
                continue

            # Safely get abstraction name
            try:
                abs_name_raw = abstractions[abs_idx].get("name", f"Chapter {i + 1}")
                abs_name = str(abs_name_raw or f"Chapter {i + 1}")
            except IndexError:
                logger.error("Index error accessing abstraction name at index %d. Using default.", abs_idx)
                abs_name = f"Chapter {i + 1}"

            # Generate filename
            safe_name = sanitize_filename(abs_name)
            filename = f"{i + 1:02d}_{safe_name}.md"

            # Get chapter content, ensuring it's a string
            ch_content_raw = chapters_content[i]
            ch_content = str(ch_content_raw or "")

            # Add footer if it's not already appended
            if not ch_content.rstrip().endswith(footer.strip()):
                ch_content += footer

            # Append chapter data to the list
            chapter_files_data.append(
                {
                    "filename": filename,
                    "content": ch_content,
                    "name": abs_name,
                    "abstraction_index": abs_idx,
                    "num": i + 1,
                }
            )

        self._log_info("Prepared data for %d chapter files.", len(chapter_files_data))
        return chapter_files_data

    def _write_output_files(
        self,
        output_path: Path,
        index_content: str,
        chapter_files_data: list[ChapterFileData],
        sequence_diagrams_markup: Optional[SequenceDiagramsList],
        diagram_config: DiagramConfigDict,
    ) -> bool:
        """Write the index.md, chapter files, and potentially separate diagram files.

        Creates the output directory if it doesn't exist. Writes the main index file,
        then iterates through chapter data to write individual chapter files. If configured,
        also writes sequence diagrams to separate files.

        Args:
            output_path: Target directory Path object for the tutorial files.
            index_content: Complete Markdown content for the index.md file.
            chapter_files_data: List of dictionaries, each containing 'filename' and 'content'.
            sequence_diagrams_markup: List of markup strings for sequence diagrams.
            diagram_config: Dictionary containing configuration for diagram generation.

        Returns:
            True if the output directory was created and index/chapter write operations
            were attempted (even if some file writes failed). False only if the base
            output directory creation fails.

        """
        write_success_flag = True  # Tracks if *all* writes succeed
        try:
            output_path.mkdir(parents=True, exist_ok=True)
            resolved_path = output_path.resolve()
            self._log_info("Ensured output directory exists: %s", resolved_path)

            # Write index file (critical step)
            index_filepath = resolved_path / "index.md"
            try:
                index_filepath.write_text(index_content, encoding="utf-8")
                self._log_info("Wrote index file: %s", index_filepath)
            except OSError as e:
                self._log_error("CRITICAL: Failed to write index file %s: %s", index_filepath, e, exc=e)
                return False  # If index can't be written, consider it a critical failure

            # Write chapter files
            for ch_info in chapter_files_data:
                fname = ch_info.get("filename")
                content = ch_info.get("content")
                if not (isinstance(fname, str) and fname and isinstance(content, str)):
                    logger.warning("Skipping chapter write due to invalid filename/content: %s", ch_info)
                    write_success_flag = False
                    continue

                ch_filepath = resolved_path / fname
                try:
                    ch_filepath.write_text(content, encoding="utf-8")
                    self._log_info("Wrote chapter file: %s", ch_filepath)
                except OSError as e:
                    self._log_error("Failed to write chapter file %s: %s", ch_filepath, e, exc=e)
                    write_success_flag = False  # Mark partial failure, but continue

            # Write separate sequence diagram files if configured AND markups exist
            if diagram_config.get("separate_markup_file_generated", False) and sequence_diagrams_markup:
                self._log_info("Writing sequence diagrams to separate files...")
                diag_format = diagram_config.get("format", "mermaid")
                seq_config = diagram_config.get("include_sequence_diagrams", {})
                scenarios_list = seq_config.get("scenarios", [])
                num_scenarios = len(scenarios_list)

                for i, seq_markup in enumerate(sequence_diagrams_markup):
                    # Determine filename based on scenario name or index
                    scenario_name = scenarios_list[i] if i < num_scenarios else f"sequence_{i + 1}"
                    safe_scenario_name = sanitize_filename(scenario_name)
                    seq_filename = f"{safe_scenario_name}.{diag_format}"
                    seq_filepath = resolved_path / seq_filename
                    try:
                        seq_filepath.write_text(seq_markup, encoding="utf-8")
                        self._log_info("Wrote sequence diagram file: %s", seq_filepath.name)
                    except OSError as e:
                        self._log_error("Failed to write sequence diagram file %s: %s", seq_filepath.name, e, exc=e)
                        write_success_flag = False  # Mark partial failure

        except OSError as e:
            # Error creating the base output directory
            self._log_error("CRITICAL: Failed to create base output directory %s: %s", output_path, e, exc=e)
            return False  # Cannot proceed if output dir fails

        if not write_success_flag:
            self._log_warning("One or more chapter or diagram file writes failed. Check previous logs.")

        # Return True indicating the write process was attempted
        return True

    def prep(self, shared: SharedState) -> CombinePrepResult:
        """Prepare all data, generate final content strings, and write output files.

        Gathers necessary data from the shared state, prepares context and footer information,
        generates index content (including diagrams based on config), prepares chapter data,
        and triggers the writing of all tutorial files to the output directory.

        Args:
            shared: The shared state dictionary containing all processed data.

        Returns:
            True if the file writing operation was successfully initiated, False if a
            critical setup error occurred.

        """
        self._log_info("Starting tutorial combination and file writing...")
        final_output_path_str: Optional[str] = None
        write_operation_initiated = False

        try:
            # Retrieve necessary data from shared state
            project_name: str = self._get_required_shared(shared, "project_name")
            output_base_dir_str: str = self._get_required_shared(shared, "output_dir")
            relationships_data: RelationshipsDict = self._get_required_shared(shared, "relationships")
            chapter_order: ChapterOrderList = self._get_required_shared(shared, "chapter_order")
            abstractions: AbstractionsList = self._get_required_shared(shared, "abstractions")
            chapters_content: ChapterContentList = self._get_required_shared(shared, "chapters")
            llm_config: dict[str, Any] = self._get_required_shared(shared, "llm_config")
            source_config: dict[str, Any] = self._get_required_shared(shared, "source_config")
            config: dict[str, Any] = self._get_required_shared(shared, "config")

            output_config = config.get("output", {})
            diagram_config: DiagramConfigDict = output_config.get("diagram_generation", {})
            repo_url: Optional[str] = shared.get("repo_url")
            local_dir: Optional[str] = shared.get("local_dir")

            # Retrieve generated diagram markups from shared state
            rel_flowchart_markup = shared.get("relationship_flowchart_markup")
            class_diag_markup = shared.get("class_diagram_markup")
            pkg_diag_markup = shared.get("package_diagram_markup")
            seq_diag_markups = shared.get("sequence_diagrams_markup")  # List[str] or None

            # Create FooterInfo
            footer_info = FooterInfo(
                provider_name=llm_config.get("provider", "UnknownProvider"),
                model_name=llm_config.get("model", "UnknownModel"),
                is_local=llm_config.get("is_local_llm", False),
                source_language=source_config.get("language", "UnknownLanguage"),
            )

            # Determine output path
            safe_project_dir_name = sanitize_filename(project_name, allow_underscores=False).replace("_", "-")
            output_path = Path(output_base_dir_str) / safe_project_dir_name

            # Prepare chapter data (adds footer)
            chapter_files_data = self._prepare_chapter_file_data(
                abstractions, chapter_order, chapters_content, footer_info
            )

            # Create IndexContext including all necessary data and configs
            index_context = IndexContext(
                project_name=project_name,
                relationships_data=relationships_data,
                footer_info=footer_info,
                repo_url=repo_url,
                local_dir=local_dir,
                relationship_flowchart_markup=rel_flowchart_markup,
                class_diagram_markup=class_diag_markup,
                package_diagram_markup=pkg_diag_markup,
                sequence_diagrams_markup=seq_diag_markups,  # Pass the list or None
                chapter_files_data=chapter_files_data,
                diagram_config=diagram_config,  # Pass the whole diagram config
            )
            # Generate Index Content (now includes sequence diagrams logic)
            index_content = self._prepare_index_content(index_context)

            # Perform file writing
            write_successful = self._write_output_files(
                output_path,
                index_content,
                chapter_files_data,
                seq_diag_markups,  # Pass markups for potential separate file writing
                diagram_config,
            )

            # Determine final status based on write_successful
            write_operation_initiated = True  # Reached writing stage
            if write_successful:
                # Even if write_successful is True, some non-critical files might have failed
                final_output_path_str = str(output_path.resolve())
                self._log_info("File writing process completed (may include partial errors).")
            else:
                # write_successful is False typically means directory or index write failed
                self._log_error("File writing failed critically (e.g., output dir or index.md).")

        except (ValueError, KeyError) as e:
            self._log_error("Missing required data in shared state for combine operation: %s", e, exc=e)
            write_operation_initiated = False
        except OSError as e_os:
            self._log_error("Filesystem error during combine preparation: %s", e_os, exc=e_os)
            write_operation_initiated = False
        except Exception as e:
            self._log_error("Unexpected error during tutorial combination preparation: %s", e, exc=e)
            write_operation_initiated = False

        finally:
            # Update shared state regardless of success/failure
            shared["final_output_dir"] = final_output_path_str
            if final_output_path_str is None and write_operation_initiated:
                self._log_warning("Final output directory could not be set due to critical write errors.")
            elif not write_operation_initiated:
                self._log_warning("Combine preparation failed; final output directory not set.")

        return write_operation_initiated

    def exec(self, prep_res: CombinePrepResult) -> CombineExecResult:
        """Execute step for CombineTutorial (no-op).

        The primary work (content preparation and file writing) is performed
        in the `prep` phase.

        Args:
            prep_res: The boolean result from the `prep` phase.

        Returns:
            None.

        """
        self._log_info("CombineTutorial exec step running (prep result: %s). No action taken.", prep_res)
        if not prep_res:
            self._log_warning("CombineTutorial prep step indicated failure or critical errors.")
        return None

    def post(self, shared: SharedState, prep_res: CombinePrepResult, exec_res: CombineExecResult) -> None:
        """Post-execution step for CombineTutorial. Logs the final completion status.

        Args:
            shared: The shared state dictionary, potentially updated with 'final_output_dir'.
            prep_res: The boolean result from the `prep` phase.
            exec_res: The result from the `exec` phase (always None).

        """
        final_dir = shared.get("final_output_dir")
        # Status depends on prep_res (critical setup/write ok) AND final_dir being set
        status = "successfully" if prep_res and final_dir else "with errors (check logs for details)"
        self._log_info(f"CombineTutorial post-processing finished {status}. Final output directory: {final_dir}")


# End of src/sourcelens/nodes/combine.py

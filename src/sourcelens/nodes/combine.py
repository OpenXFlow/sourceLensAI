# src/sourcelens/nodes/combine.py

"""Node responsible for combining generated tutorial components into final files."""

import logging
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Final, Optional, TypeAlias

from sourcelens.nodes.base_node import BaseNode, SharedState
from sourcelens.utils._exceptions import LlmApiError
from sourcelens.utils.helpers import sanitize_filename

# Type Aliases
AbstractionsList: TypeAlias = list[dict[str, Any]]
RelationshipsDict: TypeAlias = dict[str, Any]
ChapterOrderList: TypeAlias = list[int]
ChapterContentList: TypeAlias = list[str]
ChapterFileData: TypeAlias = dict[str, Any]
DiagramMarkup: TypeAlias = Optional[str]
SequenceDiagramsList: TypeAlias = list[DiagramMarkup]
DiagramConfigDict: TypeAlias = dict[str, Any]
SequenceDiagramConfigDict: TypeAlias = dict[str, Any]
IdentifiedScenarioList: TypeAlias = list[str]
SharedDataForCombine: TypeAlias = dict[str, Any]
CombinePrepResult: TypeAlias = bool
CombineExecResult: TypeAlias = None

logger = logging.getLogger(__name__)

# Constants
DIAGRAMS_CHAPTER_TITLE: Final[str] = "Architecture Diagrams"
DIAGRAMS_FILENAME_BASE: Final[str] = "diagrams"
INDEX_FILENAME: Final[str] = "index.md"
COMBINED_FLOWCHART_KEY_STR: Final[str] = "combined_flowchart_markup"
FOOTER_SEPARATOR: Final[str] = "\n\n---\n\n*Generated by"
PREV_LINK_REGEX: Final[re.Pattern[str]] = re.compile(
    r"^\s*(?:> ?)?Previously, we looked at\s+\[.*?\]\(.*?\)\.?\s*$",
    re.IGNORECASE | re.MULTILINE,
)
NEXT_LINK_REGEX: Final[re.Pattern[str]] = re.compile(
    r"^\s*(?:> ?)?Next, we will examine\s+\[.*?\]\(.*?\)\.?\s*$",
    re.IGNORECASE | re.MULTILINE,
)
# Regex to find the first H1 heading
H1_HEADING_REGEX: Final[re.Pattern[str]] = re.compile(r"^\s*#\s+.*$", re.MULTILINE)


# --- Dataclasses ---
@dataclass(frozen=True)
class FooterInfo:
    """Encapsulate information needed to generate the file footer."""

    provider_name: str
    model_name: str
    is_local: bool
    source_language: str

    def format_footer(self) -> str:
        """Generate the formatted footer string including all details."""
        location = "(local)" if self.is_local else "(cloud)"
        repo_link = "https://github.com/darijo2yahoocom/sourceLensAI"
        part1 = f"{FOOTER_SEPARATOR} [SourceLens AI]({repo_link}) "
        part2 = f"using LLM: `{self.provider_name}` {location} "
        part3 = f"- model: `{self.model_name}` | Language Profile: `{self.source_language}`*"
        return part1 + part2 + part3


@dataclass(frozen=True)
class IndexContext:
    """Encapsulate context needed to prepare the index.md file content."""

    project_name: str
    relationships_data: RelationshipsDict
    footer_info: FooterInfo
    repo_url: Optional[str] = None
    local_dir: Optional[str] = None
    relationship_flowchart_markup: DiagramMarkup = None
    chapter_files_data: list[ChapterFileData] = field(default_factory=list)
    diagram_config: DiagramConfigDict = field(default_factory=dict)
    include_rel_flowchart: bool = field(init=False)

    def __post_init__(self) -> None:
        """Set derived diagram flags after initialization."""
        include_flag = self.diagram_config.get("include_relationship_flowchart", False)
        object.__setattr__(self, "include_rel_flowchart", include_flag)


@dataclass
class DiagramMarkupContext:
    """Context for adding diagram markup."""

    content_parts: list[str]
    markup: DiagramMarkup
    diagram_title: str
    diagram_description: str
    diagram_format: str
    log_message: str


class CombineTutorial(BaseNode):
    """Combine generated tutorial parts into final Markdown files."""

    def _add_diagram_markup(self, ctx: DiagramMarkupContext) -> bool:
        """Add a diagram's markup and description using context object."""
        # ... (bez zmeny) ...
        if ctx.markup and ctx.markup.strip():
            ctx.content_parts.append(f"## {ctx.diagram_title}\n")
            ctx.content_parts.append(f"{ctx.diagram_description}\n")
            ctx.content_parts.append(f"```{ctx.diagram_format}\n{ctx.markup.strip()}\n```\n")
            self._log_info(ctx.log_message)
            return True
        return False

    def _add_sequence_diagrams_markup(
        self,
        content_parts: list[str],
        seq_diag_markups: SequenceDiagramsList,
        identified_scenarios: IdentifiedScenarioList,
        diagram_format: str,
    ) -> bool:
        """Add sequence diagrams markup with scenario descriptions."""
        # ... (bez zmeny) ...
        valid_markups_with_scenarios: list[tuple[str, str]] = []
        for i, markup_item in enumerate(seq_diag_markups):
            if markup_item and markup_item.strip():
                scenario_desc = f"Scenario {i + 1}"
                if i < len(identified_scenarios) and identified_scenarios[i] and identified_scenarios[i].strip():
                    scenario_desc = identified_scenarios[i]
                valid_markups_with_scenarios.append((scenario_desc, markup_item.strip()))

        if not valid_markups_with_scenarios:
            self._log_warning("No valid sequence diagram markups to add.")
            return False

        if not any("## Sequence Diagrams" in part for part in content_parts):
            content_parts.append("## Sequence Diagrams\n")
            content_parts.append(
                "These diagrams illustrate various interaction scenarios within the application, "
                "showcasing the sequence of operations between different components for specific use cases.\n"
            )

        for scenario_desc, seq_markup in valid_markups_with_scenarios:
            content_parts.append(f"### {scenario_desc}\n")
            content_parts.append(f"```{diagram_format}\n{seq_markup}\n```\n")

        self._log_info(
            "Adding %d Sequence Diagram(s) markup.",
            len(valid_markups_with_scenarios),
        )
        return True

    # --- REVISED _add_prev_link ---
    def _add_prev_link(self, chapter_data: ChapterFileData, prev_link_text: Optional[str]) -> None:
        """Ensure the 'Previously...' navigation link exists exactly once before H1.

        Removes all existing "Previously..." link patterns first, then inserts
        the provided link immediately before the first H1 heading (# Heading),
        separated by a blank line.

        Args:
            chapter_data: The dictionary representing the chapter data. The 'content'
                          key of this dictionary is modified in place.
            prev_link_text: The Markdown formatted link string to insert.
                            If None or empty, no link is added.

        """
        if not prev_link_text or not prev_link_text.strip():
            return

        content = str(chapter_data.get("content", "") or "")
        chapter_num_str = str(chapter_data.get("num", "Unknown"))

        # 1. Remove ALL existing "Previously..." links
        content, num_removed = PREV_LINK_REGEX.subn("", content)
        if num_removed > 0:
            self._log_info(
                "Removed %d existing 'Previously...' link(s) from chapter %s.",
                num_removed,
                chapter_num_str,
            )

        # 2. Clean up potential excessive blank lines (especially at the beginning)
        content = re.sub(r"^\s*\n", "", content)  # Remove leading blank lines
        content = re.sub(r"\n{3,}", "\n\n", content).strip()  # Reduce multiple newlines and trim ends

        # 3. Find the first H1 heading using regex
        h1_match = H1_HEADING_REGEX.search(content)

        if h1_match:
            # Found H1, insert link and newline before it
            start_index = h1_match.start()
            content = content[:start_index] + prev_link_text + "\n\n" + content[start_index:]
            self._log_info("Ensured 'Previously...' link exists before H1 in chapter %s.", chapter_num_str)
        else:
            # No H1 found, insert at the very beginning with a blank line after
            content = prev_link_text + "\n\n" + content
            self._log_warning(
                "Could not find H1 heading in chapter %s. Added 'Previously...' link at the beginning.", chapter_num_str
            )

        chapter_data["content"] = content

    def _add_next_link(self, chapter_data: ChapterFileData, next_link_text: Optional[str]) -> None:
        """Ensure the 'Next...' navigation link exists at the end."""
        # --- Logic unchanged ---
        if not next_link_text or not next_link_text.strip():
            return

        content = str(chapter_data.get("content", "") or "")
        chapter_num_str = str(chapter_data.get("num", "Unknown"))

        content, num_removed = NEXT_LINK_REGEX.subn("", content)
        if num_removed > 0:
            self._log_info(
                "Removed %d existing 'Next...' link(s) from chapter %s.",
                num_removed,
                chapter_num_str,
            )
        content = re.sub(r"\n{3,}", "\n\n", content).strip()

        if content:
            content += f"\n\n{next_link_text}"
        else:
            content = next_link_text

        chapter_data["content"] = content
        self._log_info("Ensured 'Next...' link exists in chapter %s.", chapter_num_str)

    def _add_navigation_links(
        self,
        all_chapters_data: list[ChapterFileData],
        index_filename: str,
    ) -> None:
        """Ensure consistent 'Previously...' and 'Next...' links."""
        # --- Logic unchanged ---
        num_all_chapters = len(all_chapters_data)
        if num_all_chapters == 0:
            self._log_warning("No chapters found to add navigation links.")
            return

        for i, chapter_data in enumerate(all_chapters_data):
            prev_link_text: Optional[str] = None
            if i == 0:
                # First chapter links back to index
                prev_link_text = f"Previously, we looked at the [Project Overview]({index_filename})."
            elif i > 0:
                # Other chapters link to the previous one
                prev_chapter_data = all_chapters_data[i - 1]
                prev_name = prev_chapter_data.get("name")
                prev_file = prev_chapter_data.get("filename")
                if (
                    isinstance(prev_name, str)
                    and prev_name.strip()
                    and isinstance(prev_file, str)
                    and prev_file.strip()
                ):
                    prev_link_text = f"Previously, we looked at [{prev_name.strip()}]({prev_file.strip()})."
                else:
                    self._log_warning("Could not create previous link for ch %s.", chapter_data.get("num", i + 1))

            # Always call _add_prev_link to ensure correct state
            self._add_prev_link(chapter_data, prev_link_text)

            next_link_text: Optional[str] = None
            if i < num_all_chapters - 1:
                # Any chapter except the last links to the next one
                next_chapter_data = all_chapters_data[i + 1]
                next_name = next_chapter_data.get("name")
                next_file = next_chapter_data.get("filename")
                if (
                    isinstance(next_name, str)
                    and next_name.strip()
                    and isinstance(next_file, str)
                    and next_file.strip()
                ):
                    next_link_text = f"Next, we will examine [{next_name.strip()}]({next_file.strip()})."
                else:
                    self._log_warning("Could not create next link for ch %s.", chapter_data.get("num", i + 1))

            # Always call _add_next_link to ensure correct state
            self._add_next_link(chapter_data, next_link_text)

    def _add_footers(self, all_chapters_data: list[ChapterFileData], footer_text: str) -> None:
        """Append the standard footer to all chapter contents."""
        # --- Logic unchanged ---
        clean_footer_text = footer_text.strip()
        if not clean_footer_text:
            return

        for chapter_data in all_chapters_data:
            current_content = str(chapter_data.get("content", "") or "")
            if FOOTER_SEPARATOR in current_content:
                current_content = current_content.split(FOOTER_SEPARATOR, 1)[0]

            current_content = current_content.rstrip()
            if current_content:
                current_content += f"\n{footer_text}"
            else:
                current_content = footer_text.lstrip()

            chapter_data["content"] = current_content

    # --- Helper methods for _prepare_index_content (Unchanged) ---
    def _prepare_index_header(self, context: IndexContext) -> list[str]:
        """Prepare the header section of the index.md content."""
        # ... (bez zmeny) ...
        summary_raw = context.relationships_data.get("summary", f"Tutorial for {context.project_name}.")
        summary = str(summary_raw or f"Tutorial for {context.project_name}.")
        header_parts: list[str] = [f"# Tutorial: {context.project_name}\n\n{summary}\n"]
        source_info = ""
        repo_url, local_dir = context.repo_url, context.local_dir
        if repo_url:
            source_info = f"**Source Repository:** [{repo_url}]({repo_url})"
        elif local_dir:
            try:
                source_info = f"**Source Directory:** `{Path(local_dir).resolve(strict=True)}`"
            except (OSError, ValueError, TypeError) as e:
                self._log_warning("Cannot resolve local dir path '%s': %s.", local_dir, e)
                source_info = f"**Source Directory:** `{str(local_dir)}`"
        if source_info:
            header_parts.append(f"{source_info}\n")
        return header_parts

    def _prepare_index_diagram(self, context: IndexContext) -> list[str]:
        """Prepare the diagram section of the index.md content."""
        # ... (bez zmeny) ...
        diagram_parts: list[str] = []
        diagram_format = str(context.diagram_config.get("format", "mermaid"))
        if context.include_rel_flowchart and context.relationship_flowchart_markup:
            markup = str(context.relationship_flowchart_markup)
            diagram_parts.extend(["## Abstraction Relationships\n", f"```{diagram_format}\n{markup}\n```\n"])
            self._log_info("Embedding relationship flowchart into index.md.")
        elif context.include_rel_flowchart:
            self._log_warning("Relationship flowchart enabled for index.md, but no markup was provided.")
        return diagram_parts

    def _prepare_index_chapters(self, context: IndexContext) -> list[str]:
        """Prepare the chapters section of the index.md content."""
        # ... (bez zmeny) ...
        chapter_parts: list[str] = ["## Chapters\n"]
        try:
            sorted_chapters = sorted(
                context.chapter_files_data,
                key=lambda x: (x.get("num") if isinstance(x.get("num"), int) else float("inf")),
            )
        except (TypeError, KeyError):
            self._log_warning("Cannot sort chapters based on 'num' key; using original order.")
            sorted_chapters = context.chapter_files_data
        chapter_links: list[str] = []
        for ch_data in sorted_chapters:
            num, name, fname = (
                ch_data.get("num"),
                ch_data.get("name"),
                ch_data.get("filename"),
            )
            if (
                isinstance(num, int)
                and isinstance(name, str)
                and name.strip()
                and isinstance(fname, str)
                and fname.strip()
            ):
                chapter_links.append(f"{num}. [{name.strip()}]({fname.strip()})")
            else:
                self._log_warning("Skipping chapter link due to invalid/missing data in: %s", ch_data)
        if chapter_links:
            chapter_parts.append("\n".join(chapter_links))
        else:
            chapter_parts.append("No chapters available.")
        return chapter_parts

    def _prepare_index_content(self, context: IndexContext) -> str:
        """Prepare the full Markdown content for the index.md file."""
        # ... (bez zmeny) ...
        self._log_info("Preparing index.md content...")
        content_parts: list[str] = []
        content_parts.extend(self._prepare_index_header(context))
        content_parts.extend(self._prepare_index_diagram(context))
        content_parts.extend(self._prepare_index_chapters(context))
        # Footer is added in prep()
        self._log_info("Prepared index.md content string successfully.")
        return "\n".join(content_parts)

    def _prepare_standard_chapters_data(
        self,
        abstractions: AbstractionsList,
        chapter_order: ChapterOrderList,
        chapters_content: ChapterContentList,
    ) -> list[ChapterFileData]:
        """Prepare initial data structure for standard chapter files."""
        # ... (bez zmeny) ...
        standard_chapters_data: list[ChapterFileData] = []
        num_abstractions = len(abstractions)
        num_content_items = len(chapters_content)
        num_order_items = len(chapter_order)
        effective_count = min(num_order_items, num_content_items)
        if num_order_items != num_content_items:
            self._log_warning(
                "Mismatch: order (%d) vs content (%d) count. Processing %d.",
                num_order_items,
                num_content_items,
                effective_count,
            )
        for i in range(effective_count):
            abs_idx = chapter_order[i]
            if not (0 <= abs_idx < num_abstractions):
                self._log_warning("Skipping prep: Invalid abstraction index %d.", abs_idx)
                continue
            try:
                abs_item = abstractions[abs_idx]
                abs_name_raw = abs_item.get("name", f"Chapter {i + 1}")
                abs_name = str(abs_name_raw or f"Chapter {i + 1}")
            except IndexError:
                self._log_error("IndexError accessing abstraction name at index %d.", abs_idx, exc_info=True)
                abs_name = f"Chapter {i + 1}"
            safe_name = sanitize_filename(abs_name)
            filename = f"{i + 1:02d}_{safe_name}.md"
            ch_content = str(chapters_content[i] or "")
            standard_chapters_data.append(
                {
                    "filename": filename,
                    "content": ch_content,
                    "name": abs_name,
                    "abstraction_index": abs_idx,
                    "num": i + 1,
                }
            )
        self._log_info(
            "Prepared initial data for %d standard chapter files.",
            len(standard_chapters_data),
        )
        return standard_chapters_data

    def _prepare_diagrams_chapter_data(
        self,
        shared: SharedState,
        diagram_config: DiagramConfigDict,
        next_chapter_num: int,
    ) -> Optional[ChapterFileData]:
        """Prepare the data structure for the dedicated diagrams chapter."""
        # ... (bez zmeny) ...
        content_parts: list[str] = [f"# {DIAGRAMS_CHAPTER_TITLE}\n"]
        diagram_format = str(diagram_config.get("format", "mermaid"))
        project_name = str(shared.get("project_name", "the project"))
        has_content = False
        if bool(diagram_config.get("include_class_diagram", False)):
            markup = str(markup_val) if (markup_val := shared.get("class_diagram_markup")) else None
            desc = f"Key classes in **{project_name}**, attributes, methods, and relationships."
            markup_ctx = DiagramMarkupContext(
                content_parts=content_parts,
                markup=markup,
                diagram_title="Class Diagram",
                diagram_description=desc,
                diagram_format=diagram_format,
                log_message="Adding Class Diagram.",
            )
            if self._add_diagram_markup(markup_ctx):
                has_content = True
            else:
                self._log_warning("Class diagram on but no markup.")
        if bool(diagram_config.get("include_package_diagram", False)):
            markup = str(markup_val) if (markup_val := shared.get("package_diagram_markup")) else None
            desc = f"High-level modular structure of **{project_name}** and dependencies."
            markup_ctx = DiagramMarkupContext(
                content_parts=content_parts,
                markup=markup,
                diagram_title="Package Dependencies",
                diagram_description=desc,
                diagram_format=diagram_format,
                log_message="Adding Package Diagram.",
            )
            if self._add_diagram_markup(markup_ctx):
                has_content = True
            else:
                self._log_warning("Package diagram on but no markup.")
        seq_conf_raw = diagram_config.get("include_sequence_diagrams", {})
        seq_conf: SequenceDiagramConfigDict = seq_conf_raw if isinstance(seq_conf_raw, dict) else {}
        if bool(seq_conf.get("enabled", False)):
            markups_raw = shared.get("sequence_diagrams_markup", [])
            markups: SequenceDiagramsList = (
                [str(m) if m else None for m in markups_raw] if isinstance(markups_raw, list) else []
            )
            scenarios_raw = shared.get("identified_scenarios", [])
            scenarios: IdentifiedScenarioList = (
                [str(s) for s in scenarios_raw if isinstance(s, str)] if isinstance(scenarios_raw, list) else []
            )
            if self._add_sequence_diagrams_markup(content_parts, markups, scenarios, diagram_format):
                has_content = True
            else:
                self._log_warning("Sequence diagrams on but no markups.")
        if has_content:
            return {
                "filename": f"{next_chapter_num:02d}_{DIAGRAMS_FILENAME_BASE}.md",
                "content": "\n".join(content_parts),
                "name": DIAGRAMS_CHAPTER_TITLE,
                "num": next_chapter_num,
                "abstraction_index": -1,
            }
        self._log_info("No diagram content for diagrams chapter.")
        return None

    def _write_output_files(
        self,
        output_path: Path,
        index_content: str,
        all_chapter_files_data: list[ChapterFileData],
    ) -> bool:
        """Write the index.md and all generated chapter files."""
        # ... (bez zmeny) ...
        try:
            output_path.mkdir(parents=True, exist_ok=True)
            self._log_info("Ensured output directory exists: %s", output_path.resolve())
            index_filepath = output_path / INDEX_FILENAME
            try:
                index_filepath.write_text(index_content, encoding="utf-8")
                self._log_info("Wrote index file: %s", index_filepath)
            except OSError as e_index:
                self._log_error("CRITICAL: Failed to write index file %s: %s", index_filepath, e_index, exc_info=True)
                return False
            all_chapter_writes_successful = True
            for ch_info in all_chapter_files_data:
                fname, content = ch_info.get("filename"), ch_info.get("content")
                if not (isinstance(fname, str) and fname and isinstance(content, str)):
                    logger.warning("Skipping chapter write due to invalid data: %s", ch_info)
                    all_chapter_writes_successful = False
                    continue
                ch_filepath = output_path / fname
                try:
                    ch_filepath.write_text(content, encoding="utf-8")
                    self._log_info("Wrote chapter file: %s ('%s')", ch_filepath, ch_info.get("name", "Unknown"))
                except OSError as e_chap:
                    self._log_error(
                        "Failed to write chapter %s ('%s'): %s",
                        ch_filepath,
                        ch_info.get("name", "Unknown"),
                        e_chap,
                        exc_info=True,
                    )
                    all_chapter_writes_successful = False
            if not all_chapter_writes_successful:
                self._log_warning("One or more chapter file writes failed. Check logs.")
            return True
        except OSError as e_dir:
            self._log_error(
                "CRITICAL: Failed to create base output directory %s: %s", output_path, e_dir, exc_info=True
            )
            return False

    def _retrieve_shared_data(self, shared: SharedState) -> SharedDataForCombine:
        """Retrieve all necessary data from shared state for combination."""
        # ... (bez zmeny) ...
        return {
            "project_name": self._get_required_shared(shared, "project_name"),
            "output_base_dir": self._get_required_shared(shared, "output_dir"),
            "relationships_data": self._get_required_shared(shared, "relationships"),
            "chapter_order": self._get_required_shared(shared, "chapter_order"),
            "abstractions": self._get_required_shared(shared, "abstractions"),
            "chapters_content": self._get_required_shared(shared, "chapters"),
            "llm_config": self._get_required_shared(shared, "llm_config"),
            "source_config": self._get_required_shared(shared, "source_config"),
            "config": self._get_required_shared(shared, "config"),
            "repo_url": shared.get("repo_url"),
            "local_dir": shared.get("local_dir"),
            "rel_flowchart_markup": shared.get("relationship_flowchart_markup"),
        }

    # --- Refactored Helpers for prep (PLR0915 fix) ---
    def _initialize_combine_data(self, shared: SharedState) -> tuple[SharedDataForCombine, FooterInfo, Path]:
        """Retrieve shared data, setup footer and output path."""
        # ... (bez zmeny) ...
        data = self._retrieve_shared_data(shared)
        llm_cfg = data["llm_config"]
        src_cfg = data["source_config"]
        footer_info = FooterInfo(
            str(llm_cfg.get("provider", "N/A")),
            str(llm_cfg.get("model", "N/A")),
            bool(llm_cfg.get("is_local_llm", False)),
            str(src_cfg.get("language", "N/A")),
        )
        safe_project_name = sanitize_filename(data["project_name"], allow_underscores=False)
        output_path = Path(data["output_base_dir"]) / safe_project_name
        return data, footer_info, output_path

    def _assemble_chapters(self, shared: SharedState, data: SharedDataForCombine) -> list[ChapterFileData]:
        """Prepare standard and diagram chapters."""
        # ... (bez zmeny) ...
        output_config = data["config"].get("output", {})
        diagram_config_raw = output_config.get("diagram_generation", {})
        diagram_config: DiagramConfigDict = diagram_config_raw if isinstance(diagram_config_raw, dict) else {}
        std_chapters = self._prepare_standard_chapters_data(
            data["abstractions"],
            data["chapter_order"],
            data["chapters_content"],
        )
        diag_chapter = self._prepare_diagrams_chapter_data(shared, diagram_config, len(std_chapters) + 1)
        all_chapters: list[ChapterFileData] = list(std_chapters)
        if diag_chapter:
            all_chapters.append(diag_chapter)
        return all_chapters

    # --- Core Node Methods ---
    def prep(self, shared: SharedState) -> CombinePrepResult:
        """Prepare all data, ensure consistent links/footers, write output."""
        # ... (bez zmeny) ...
        self._log_info("Starting tutorial combination and file writing process...")
        write_successful = False
        output_path: Optional[Path] = None
        try:
            data, footer_info, output_path = self._initialize_combine_data(shared)
            rel_flowchart_markup = data["rel_flowchart_markup"]
            if not isinstance(rel_flowchart_markup, (str, type(None))):
                rel_flowchart_markup = None
            all_chapters = self._assemble_chapters(shared, data)
            footer_text = footer_info.format_footer()
            if not all_chapters and not rel_flowchart_markup:
                self._log_warning("No content to combine. Skipping file writes.")
                shared["final_output_dir"] = str(output_path.resolve())
                return True
            self._add_navigation_links(all_chapters, INDEX_FILENAME)
            self._add_footers(all_chapters, footer_text)
            output_config = data["config"].get("output", {})
            diagram_config: DiagramConfigDict = output_config.get("diagram_generation", {})
            idx_ctx = IndexContext(
                project_name=data["project_name"],
                relationships_data=data["relationships_data"],
                footer_info=footer_info,
                repo_url=data["repo_url"],
                local_dir=data["local_dir"],
                relationship_flowchart_markup=rel_flowchart_markup,
                chapter_files_data=all_chapters,
                diagram_config=diagram_config,
            )
            index_content = self._prepare_index_content(idx_ctx)
            if FOOTER_SEPARATOR not in index_content:
                index_content = index_content.rstrip() + f"\n{footer_text}"
            write_successful = self._write_output_files(output_path, index_content, all_chapters)
            if write_successful:
                shared["final_output_dir"] = str(output_path.resolve())
                self._log_info("File writing initiated (index.md written).")
            else:
                shared["final_output_dir"] = None
        except ValueError:
            shared["final_output_dir"] = None
            raise
        except OSError as e_os:
            self._log_error("Combine.prep: Filesystem error: %s", e_os, exc_info=True)
            shared["final_output_dir"] = None
        except Exception as e_comb:
            self._log_error("Combine.prep: Unexpected error: %s", e_comb, exc_info=True)
            shared["final_output_dir"] = None
            raise LlmApiError(f"Combine step failed unexpectedly: {e_comb}") from e_comb
        return write_successful

    def exec(self, prep_res: CombinePrepResult) -> CombineExecResult:
        """Execute step for CombineTutorial (no-op)."""
        # ... (bez zmeny) ...
        self._log_info("CombineTutorial.exec: No action taken (prep result: %s).", prep_res)
        if not prep_res:
            self._log_warning("CombineTutorial.exec: Prep step indicated critical failure.")
        return None

    def post(
        self,
        shared: SharedState,
        prep_res: CombinePrepResult,
        exec_res: CombineExecResult,
    ) -> None:
        """Post-execution step for CombineTutorial."""
        # ... (bez zmeny) ...
        final_dir = shared.get("final_output_dir")
        status_msg = "successfully" if prep_res and final_dir else "with critical errors"
        self._log_info(
            "CombineTutorial.post: Processing finished %s. Final output directory: %s",
            status_msg,
            final_dir,
        )


# End of src/sourcelens/nodes/combine.py

# src/sourcelens/nodes/combine.py

"""Node responsible for combining generated tutorial components into final files."""

import logging
from dataclasses import dataclass, field
from pathlib import Path

# Using Final from typing
from typing import Any, Final, Optional, TypeAlias

from sourcelens.nodes.base_node import BaseNode, SharedState

# >>> REMOVED unnecessary import <<<
# from sourcelens.nodes.generate_diagrams import COMBINED_FLOWCHART_KEY
from sourcelens.utils._exceptions import LlmApiError
from sourcelens.utils.helpers import sanitize_filename

# --- Type Aliases ---
AbstractionsList: TypeAlias = list[dict[str, Any]]
RelationshipsDict: TypeAlias = dict[str, Any]
ChapterOrderList: TypeAlias = list[int]
ChapterContentList: TypeAlias = list[str]
ChapterFileData: TypeAlias = dict[str, Any]
DiagramMarkup: TypeAlias = Optional[str]
SequenceDiagramsList: TypeAlias = list[DiagramMarkup]
DiagramConfigDict: TypeAlias = dict[str, Any]
SequenceDiagramConfigDict: TypeAlias = dict[str, Any]
IdentifiedScenarioList: TypeAlias = list[str]
SharedDataForCombine: TypeAlias = dict[str, Any]

CombinePrepResult: TypeAlias = bool
CombineExecResult: TypeAlias = None

logger = logging.getLogger(__name__)

# --- Constants ---
DIAGRAMS_CHAPTER_TITLE: Final[str] = "Architecture Diagrams"
DIAGRAMS_FILENAME_BASE: Final[str] = "diagrams"
INDEX_FILENAME: Final[str] = "index.md"
DEFAULT_INTRO_PHRASE: Final[str] = "Let's begin exploring this concept."
DEFAULT_CONCLUSION_PHRASE: Final[str] = "This concludes our look at this topic."
# Define the key as a string literal here for clarity
COMBINED_FLOWCHART_KEY_STR: Final[str] = "combined_flowchart_markup"


# --- Dataclasses ---
@dataclass(frozen=True)
class FooterInfo:
    """Encapsulate information needed to generate the file footer.

    Attributes:
        provider_name: Name of the LLM provider used.
        model_name: Name of the LLM model used.
        is_local: Flag indicating if the LLM is local.
        source_language: The language profile used for analysis.

    """

    provider_name: str
    model_name: str
    is_local: bool
    source_language: str

    def format_footer(self) -> str:
        """Generate the formatted footer string including all details.

        Returns:
            A formatted Markdown string for the file footer.

        """
        location = "(local)" if self.is_local else "(cloud)"
        repo_link = "https://github.com/darijo2yahoocom/sourceLensAI"
        part1 = f"\n\n---\n\n*Generated by [SourceLens AI]({repo_link}) "
        part2 = f"using LLM: `{self.provider_name}` {location} "
        part3 = f"- model: `{self.model_name}` | Language Profile: `{self.source_language}`*"
        return part1 + part2 + part3


@dataclass(frozen=True)
class IndexContext:
    """Encapsulate context needed to prepare the index.md file content.

    Attributes:
        project_name: The name of the project.
        relationships_data: Dictionary containing relationship summary/details.
        footer_info: FooterInfo dataclass instance.
        repo_url: The URL of the source GitHub repository, if applicable.
        local_dir: The path to the source local directory, if applicable.
        relationship_flowchart_markup: Mermaid markup for simple relationship flowchart.
        chapter_files_data: List of dictionaries representing chapter files.
        diagram_config: The 'diagram_generation' section from configuration.
        include_rel_flowchart: Flag indicating if diagram should be included.

    """

    project_name: str
    relationships_data: RelationshipsDict
    footer_info: FooterInfo
    repo_url: Optional[str] = None
    local_dir: Optional[str] = None
    relationship_flowchart_markup: DiagramMarkup = None
    chapter_files_data: list[ChapterFileData] = field(default_factory=list)
    diagram_config: DiagramConfigDict = field(default_factory=dict)
    include_rel_flowchart: bool = field(init=False)

    def __post_init__(self) -> None:
        """Set derived diagram flags after initialization."""
        include_flag = self.diagram_config.get("include_relationship_flowchart", False)
        object.__setattr__(self, "include_rel_flowchart", include_flag)


class CombineTutorial(BaseNode):
    """Combine generated tutorial parts into final Markdown files.

    Assembles index.md (with simple relationship flowchart), standard chapter
    files, and a dedicated diagrams chapter. Adds attributions and footer,
    handles cross-linking, and writes the tutorial structure.
    """

    # --- Helper methods for Diagram Chapter ---
    def _add_diagram_markup(
        self, content_parts: list[str], markup: DiagramMarkup, title: str, diagram_format: str, log_message: str
    ) -> bool:
        """Add diagram markup to content parts if markup exists."""
        if markup:
            content_parts.extend([f"## {title}\n", f"```{diagram_format}\n{markup}\n```\n"])
            self._log_info(log_message)
            return True
        return False

    def _add_sequence_diagrams_markup(
        self,
        content_parts: list[str],
        seq_diag_markups: SequenceDiagramsList,
        identified_scenarios: IdentifiedScenarioList,
        diagram_format: str,
    ) -> bool:
        """Add sequence diagrams markup to content parts."""
        valid_markups = [m for m in seq_diag_markups if m]
        if not valid_markups:
            return False
        content_parts.append("## Sequence Diagrams\n")
        num_valid_markups = len(valid_markups)
        num_scenarios = len(identified_scenarios)
        if num_valid_markups != num_scenarios and num_scenarios > 0:
            logger.warning("Mismatch: %d seq markups vs %d scenarios.", num_valid_markups, num_scenarios)
        for i, seq_markup in enumerate(valid_markups):
            scenario_title = f"Scenario {i + 1}"
            if i < num_scenarios:
                scenario_title = identified_scenarios[i] or scenario_title
            content_parts.extend([f"### {scenario_title}\n", f"```{diagram_format}\n{seq_markup}\n```\n"])
        self._log_info("Adding %d Sequence Diagram(s) markup.", num_valid_markups)
        return True

    # --- Helper methods for Navigation & Footers ---
    def _add_prev_link(self, chapter_data: ChapterFileData, prev_link_text: Optional[str]) -> None:
        """Add 'Previously...' link to the beginning of chapter content."""
        if not prev_link_text:
            return
        content = str(chapter_data.get("content", "") or "")
        chapter_num = chapter_data.get("num", "Unknown")
        chapter_name = str(chapter_data.get("name", ""))
        is_diagrams_chapter = chapter_name == DIAGRAMS_CHAPTER_TITLE
        heading_prefix = f"# {chapter_name}" if not is_diagrams_chapter else f"# {DIAGRAMS_CHAPTER_TITLE}"
        if prev_link_text in content:
            self._log_info("'Previously...' link present in chapter %s.", chapter_num)
            return
        lines = content.split("\n")
        insert_index = 0
        heading_found = False
        for i, line in enumerate(lines):
            line_strip = line.strip()
            if line_strip.startswith(heading_prefix):
                heading_found = True
                insert_index = i + 1
            elif heading_found and line_strip:
                insert_index = i
                break
            elif i == len(lines) - 1:
                insert_index = i + 1
                break
        lines.insert(insert_index, "")
        lines.insert(insert_index + 1, prev_link_text)
        if insert_index + 2 <= len(lines):
            lines.insert(insert_index + 2, "")
        else:
            lines.append("")
        chapter_data["content"] = "\n".join(lines)
        self._log_info("Added 'Previously...' link to chapter %s.", chapter_num)

    def _add_next_link(self, chapter_data: ChapterFileData, next_link_text: Optional[str]) -> None:
        """Add 'Next...' link to the end of chapter content (before footer)."""
        if not next_link_text:
            return
        content = str(chapter_data.get("content", "") or "")
        chapter_num = chapter_data.get("num", "Unknown")
        if next_link_text not in content:
            content += f"\n\n{next_link_text}"
            chapter_data["content"] = content
            self._log_info("Added 'Next...' link to chapter %s.", chapter_num)
        else:
            self._log_info("'Next...' link already present in chapter %s.", chapter_num)

    def _add_navigation_links(self, all_chapters_data: list[ChapterFileData], index_filename: str) -> None:
        """Add 'Previously...' and 'Next...' links to chapter contents."""
        num_all_chapters = len(all_chapters_data)
        if num_all_chapters == 0:
            return
        for i, chapter_data in enumerate(all_chapters_data):
            prev_link_text: Optional[str] = None
            if i == 0:
                prev_link_text = f"Previously, we looked at the [Project Overview]({index_filename})."
            elif i > 0:
                prev_chapter_data = all_chapters_data[i - 1]
                prev_name = prev_chapter_data.get("name")
                prev_file = prev_chapter_data.get("filename")
                if isinstance(prev_name, str) and isinstance(prev_file, str):
                    prev_link_text = f"Previously, we looked at [{prev_name}]({prev_file})."
                else:
                    logger.warning("Could not get prev link info for chapter %d.", i + 1)
            self._add_prev_link(chapter_data, prev_link_text)
            next_link_text: Optional[str] = None
            if i < num_all_chapters - 1:
                next_chapter_data = all_chapters_data[i + 1]
                next_name = next_chapter_data.get("name")
                next_file = next_chapter_data.get("filename")
                if isinstance(next_name, str) and isinstance(next_file, str):
                    next_link_text = f"Next, we will examine [{next_name}]({next_file})."
                else:
                    logger.warning("Could not get next link info for chapter %d.", i + 1)
            self._add_next_link(chapter_data, next_link_text)

    def _add_footers(self, all_chapters_data: list[ChapterFileData], footer_text: str) -> None:
        """Append the footer to all chapter contents."""
        for chapter_data in all_chapters_data:
            current_content = str(chapter_data.get("content", "") or "")
            if not current_content.strip().endswith(footer_text.strip()):
                current_content += f"\n{footer_text}" if current_content.strip() else footer_text
            chapter_data["content"] = current_content

    # --- Core Node Methods ---
    def _prepare_index_content(self, context: IndexContext) -> str:
        """Prepare the full Markdown content for the index.md file."""
        self._log_info("Preparing index.md content...")
        summary_raw = context.relationships_data.get("summary", f"Tutorial for {context.project_name}.")
        summary = str(summary_raw or f"Tutorial for {context.project_name}.")
        index_content_parts: list[str] = [f"# Tutorial: {context.project_name}\n\n{summary}\n"]
        source_info = ""
        repo_url = context.repo_url
        local_dir = context.local_dir
        if repo_url:
            source_info = f"**Source Repository:** [{repo_url}]({repo_url})"
        elif local_dir:
            try:
                resolved_path = Path(local_dir).resolve(strict=True)
                source_info = f"**Source Directory:** `{resolved_path}`"
            except (OSError, ValueError, TypeError) as e:
                logger.warning("Cannot resolve local dir path '%s': %s.", local_dir, e)
                source_info = f"**Source Directory:** `{str(local_dir)}`"
        if source_info:
            index_content_parts.append(f"{source_info}\n")
        diagram_format = context.diagram_config.get("format", "mermaid")
        if context.include_rel_flowchart:
            if context.relationship_flowchart_markup:
                markup = str(context.relationship_flowchart_markup)
                index_content_parts.extend(["## Abstraction Relationships\n", f"```{diagram_format}\n{markup}\n```\n"])
                self._log_info("Embedding relationship flowchart.")
            else:
                self._log_warning("Relationship flowchart enabled but no markup found.")
        index_content_parts.append("## Chapters\n")
        try:
            sorted_chapters = sorted(
                context.chapter_files_data,
                key=lambda x: x.get("num") if isinstance(x.get("num"), int) else float("inf"),
            )
        except (TypeError, KeyError):
            logger.warning("Cannot sort chapters.")
            sorted_chapters = context.chapter_files_data
        chapter_links = [
            f"{ch.get('num')}. [{ch.get('name')}]({ch.get('filename')})"
            for ch in sorted_chapters
            if isinstance(ch.get("num"), int)
            and isinstance(ch.get("name"), str)
            and isinstance(ch.get("filename"), str)
        ]
        if len(chapter_links) != len(sorted_chapters):
            logger.warning("Skipped some chapter links due to invalid data format.")
        index_content_parts.append("\n".join(chapter_links))
        index_content_parts.append(context.footer_info.format_footer())
        self._log_info("Prepared index.md content string.")
        return "\n".join(index_content_parts)

    def _prepare_standard_chapters_data(
        self, abstractions: AbstractionsList, chapter_order: ChapterOrderList, chapters_content: ChapterContentList
    ) -> list[ChapterFileData]:
        """Prepare initial data structure for standard chapter files."""
        standard_chapters_data: list[ChapterFileData] = []
        num_abstractions = len(abstractions)
        num_content_items = len(chapters_content)
        num_order_items = len(chapter_order)
        effective_chapter_count = min(num_order_items, num_content_items)
        if num_order_items != num_content_items:
            logger.warning(
                "Mismatch: order (%d) vs content (%d). Processing %d.",
                num_order_items,
                num_content_items,
                effective_chapter_count,
            )
        for i in range(effective_chapter_count):
            abs_idx = chapter_order[i]
            if not (0 <= abs_idx < num_abstractions):
                logger.warning("Skipping prep: Invalid abs index %d.", abs_idx)
                continue
            try:
                abs_name_raw = abstractions[abs_idx].get("name", f"Chapter {i + 1}")
                abs_name = str(abs_name_raw or f"Chapter {i + 1}")
            except IndexError:
                logger.error("Index error accessing abs name %d.", abs_idx, exc_info=True)
                abs_name = f"Chapter {i + 1}"
            safe_name = sanitize_filename(abs_name)
            filename = f"{i + 1:02d}_{safe_name}.md"
            ch_content_raw = chapters_content[i]
            ch_content = str(ch_content_raw or "")  # Ensure string
            standard_chapters_data.append(
                {
                    "filename": filename,
                    "content": ch_content,
                    "name": abs_name,
                    "abstraction_index": abs_idx,
                    "num": i + 1,
                }
            )
        self._log_info("Prepared initial data for %d standard chapter files.", len(standard_chapters_data))
        return standard_chapters_data

    def _prepare_diagrams_chapter_data(
        self, shared: SharedState, diagram_config: DiagramConfigDict, next_chapter_num: int
    ) -> Optional[ChapterFileData]:
        """Prepare the data structure for the dedicated diagrams chapter."""
        # ... (Uses string literal COMBINED_FLOWCHART_KEY_STR) ...
        content_parts: list[str] = []
        diagram_format = diagram_config.get("format", "mermaid")
        include_class = diagram_config.get("include_class_diagram", False)
        include_pkg = diagram_config.get("include_package_diagram", False)
        seq_config_raw = diagram_config.get("include_sequence_diagrams", {})
        seq_config: SequenceDiagramConfigDict = seq_config_raw if isinstance(seq_config_raw, dict) else {}
        include_seq = seq_config.get("enabled", False)
        include_combined = diagram_config.get("include_combined_flowchart", False)
        class_diag_markup: DiagramMarkup = (
            str(shared.get("class_diagram_markup")) if shared.get("class_diagram_markup") else None
        )
        pkg_diag_markup: DiagramMarkup = (
            str(shared.get("package_diagram_markup")) if shared.get("package_diagram_markup") else None
        )
        combined_markup: DiagramMarkup = (
            str(shared.get(COMBINED_FLOWCHART_KEY_STR)) if shared.get(COMBINED_FLOWCHART_KEY_STR) else None
        )
        seq_diag_markups_raw = shared.get("sequence_diagrams_markup")
        seq_diag_markups: SequenceDiagramsList = (
            [str(m) if m else None for m in seq_diag_markups_raw] if isinstance(seq_diag_markups_raw, list) else []
        )
        identified_scenarios_raw = shared.get("identified_scenarios", [])
        identified_scenarios: IdentifiedScenarioList = (
            [str(s) for s in identified_scenarios_raw if isinstance(s, str)]
            if isinstance(identified_scenarios_raw, list)
            else []
        )
        has_content = False
        if self._add_diagram_markup(
            content_parts,
            combined_markup,
            "Combined Relationships & Modules",
            diagram_format,
            "Adding Combined Flowchart markup.",
        ):
            has_content = True
        elif include_combined:
            self._log_warning("Combined flowchart enabled but no markup found.")
        if self._add_diagram_markup(
            content_parts, class_diag_markup, "Class Diagram", diagram_format, "Adding Class Diagram markup."
        ):
            has_content = True
        elif include_class:
            self._log_warning("Class diagram enabled but no markup found.")
        if self._add_diagram_markup(
            content_parts, pkg_diag_markup, "Package Dependencies", diagram_format, "Adding Package Diagram markup."
        ):
            has_content = True
        elif include_pkg:
            self._log_warning("Package diagram enabled but no markup found.")
        if include_seq and self._add_sequence_diagrams_markup(
            content_parts, seq_diag_markups, identified_scenarios, diagram_format
        ):
            has_content = True
        elif include_seq:
            self._log_warning("Sequence diagrams enabled but no valid markups found.")
        if has_content:
            full_content = f"# {DIAGRAMS_CHAPTER_TITLE}\n\n" + "\n".join(content_parts)
            diagrams_filename = f"{next_chapter_num:02d}_{DIAGRAMS_FILENAME_BASE}.md"
            self._log_info("Prepared initial data for '%s' chapter (%s).", DIAGRAMS_CHAPTER_TITLE, diagrams_filename)
            return {
                "filename": diagrams_filename,
                "content": full_content,
                "name": DIAGRAMS_CHAPTER_TITLE,
                "num": next_chapter_num,
                "abstraction_index": -1,
            }
        self._log_info("No diagram content generated for diagrams chapter.")
        return None

    def _write_output_files(
        self, output_path: Path, index_content: str, all_chapter_files_data: list[ChapterFileData]
    ) -> bool:
        """Write the index.md and all chapter files."""
        try:
            output_path.mkdir(parents=True, exist_ok=True)
            resolved_path = output_path.resolve()
            self._log_info("Ensured output directory exists: %s", resolved_path)
            index_filepath = resolved_path / INDEX_FILENAME
            try:
                index_filepath.write_text(index_content, encoding="utf-8")
                self._log_info("Wrote index file: %s", index_filepath)
            except OSError as e_index:
                self._log_error("CRITICAL: Failed write index %s: %s", index_filepath, e_index, exc_info=True)
                return False
            all_writes_successful = True
            for ch_info in all_chapter_files_data:
                fname = ch_info.get("filename")
                content = ch_info.get("content")
                chapter_name = ch_info.get("name", "Unknown")
                if not (isinstance(fname, str) and fname and isinstance(content, str)):
                    logger.warning("Skipping chapter write invalid data: %s", ch_info)
                    all_writes_successful = False
                    continue
                ch_filepath = resolved_path / fname
                try:
                    ch_filepath.write_text(content, encoding="utf-8")
                    self._log_info("Wrote chapter file: %s ('%s')", ch_filepath, chapter_name)
                except OSError as e_chap:
                    self._log_error(
                        "Failed write chapter %s ('%s'): %s", ch_filepath, chapter_name, e_chap, exc_info=True
                    )
                    all_writes_successful = False
            if not all_writes_successful:
                self._log_warning("One or more chapter file writes failed.")
            return True
        except OSError as e_dir:
            self._log_error("CRITICAL: Failed create output dir %s: %s", output_path, e_dir, exc_info=True)
            return False

    def _retrieve_shared_data(self, shared: SharedState) -> SharedDataForCombine:
        """Retrieve all necessary data from shared state for combination."""
        return {
            "project_name": self._get_required_shared(shared, "project_name"),
            "output_base_dir": self._get_required_shared(shared, "output_dir"),
            "relationships_data": self._get_required_shared(shared, "relationships"),
            "chapter_order": self._get_required_shared(shared, "chapter_order"),
            "abstractions": self._get_required_shared(shared, "abstractions"),
            "chapters_content": self._get_required_shared(shared, "chapters"),
            "llm_config": self._get_required_shared(shared, "llm_config"),
            "source_config": self._get_required_shared(shared, "source_config"),
            "config": self._get_required_shared(shared, "config"),
            "repo_url": shared.get("repo_url"),
            "local_dir": shared.get("local_dir"),
            "rel_flowchart_markup": shared.get("relationship_flowchart_markup"),
        }

    def prep(self, shared: SharedState) -> CombinePrepResult:
        """Prepare data, generate content, add footers/links, write files."""
        self._log_info("Starting tutorial combination and file writing...")
        final_output_path_str: Optional[str] = None
        write_operation_initiated = False
        write_successful = False
        try:
            retrieved_data = self._retrieve_shared_data(shared)
            output_config = retrieved_data["config"].get("output", {})
            diagram_config_raw = output_config.get("diagram_generation", {})
            diagram_config: DiagramConfigDict = diagram_config_raw if isinstance(diagram_config_raw, dict) else {}
            llm_config = retrieved_data["llm_config"]
            source_config = retrieved_data["source_config"]
            rel_flowchart_markup = retrieved_data["rel_flowchart_markup"]
            if not isinstance(rel_flowchart_markup, (str, type(None))):
                rel_flowchart_markup = None
            footer_info = FooterInfo(
                str(llm_config.get("provider", "Unknown")),
                str(llm_config.get("model", "Unknown")),
                bool(llm_config.get("is_local_llm", False)),
                str(source_config.get("language", "Unknown")),
            )
            footer_text = footer_info.format_footer()
            safe_project_dir_name = sanitize_filename(retrieved_data["project_name"], allow_underscores=False)
            output_path = Path(retrieved_data["output_base_dir"]) / safe_project_dir_name
            standard_chapters_data: list[ChapterFileData] = self._prepare_standard_chapters_data(
                retrieved_data["abstractions"], retrieved_data["chapter_order"], retrieved_data["chapters_content"]
            )
            next_chap_num = len(standard_chapters_data) + 1
            diagrams_chapter_data = self._prepare_diagrams_chapter_data(
                shared=shared, diagram_config=diagram_config, next_chapter_num=next_chap_num
            )
            all_chapters_data = list(standard_chapters_data)
            if diagrams_chapter_data:
                all_chapters_data.append(diagrams_chapter_data)
            index_context = IndexContext(
                project_name=retrieved_data["project_name"],
                relationships_data=retrieved_data["relationships_data"],
                footer_info=footer_info,
                repo_url=retrieved_data["repo_url"],
                local_dir=retrieved_data["local_dir"],
                relationship_flowchart_markup=rel_flowchart_markup,
                chapter_files_data=all_chapters_data,
                diagram_config=diagram_config,
            )
            index_content = self._prepare_index_content(index_context)
            self._add_navigation_links(all_chapters_data, INDEX_FILENAME)
            self._add_footers(all_chapters_data, footer_text)
            write_successful = self._write_output_files(output_path, index_content, all_chapters_data)
            write_operation_initiated = True
            if write_successful:
                final_output_path_str = str(output_path.resolve())
                self._log_info("File writing initiated (index written).")
            else:
                self._log_error("File writing failed critically.")
                final_output_path_str = None
        except ValueError as e_val:
            self._log_error("Missing required data: %s", e_val, exc_info=True)
            raise
        except OSError as e_os:
            self._log_error("Filesystem error during combine: %s", e_os, exc_info=True)
            write_operation_initiated = True
        except Exception as e_comb:
            self._log_error("Unexpected error during combination: %s", e_comb, exc_info=True)
            write_operation_initiated = True
            raise LlmApiError(f"Combine step failed unexpectedly: {e_comb}") from e_comb
        finally:
            shared["final_output_dir"] = final_output_path_str
            if final_output_path_str is None:
                log_msg = (
                    "Final dir not set due to critical write errors."
                    if write_operation_initiated
                    else "Combine prep failed; final dir not set."
                )
                self._log_warning(log_msg)
        return write_successful

    def exec(self, prep_res: CombinePrepResult) -> CombineExecResult:
        """Execute step for CombineTutorial (no-op)."""
        self._log_info("CombineTutorial exec step (prep ok: %s). No action.", prep_res)
        return None

    def post(self, shared: SharedState, prep_res: CombinePrepResult, exec_res: CombineExecResult) -> None:
        """Post-execution step for CombineTutorial."""
        final_dir = shared.get("final_output_dir")
        status = "successfully" if prep_res and final_dir else "with errors"
        self._log_info(f"CombineTutorial post finished {status}. Final dir: {final_dir}")


# End of src/sourcelens/nodes/combine.py

Previously, we looked at [Configuration Management](01_configuration-management.md).

# Chapter 2: Data Model (Item)
Let's begin exploring this concept. In this chapter, we will define the structure of our core data element: the `Item`.
Imagine you're building a digital shopping list. Each item on that list has certain properties: its name (like "Milk"), a quantity (like "1 liter"), and perhaps a priority. Similarly, in our application, we need a way to represent individual pieces of data, and that's where the `Item` data model comes in. It's like a blueprint for creating these data items.
The `Item` data model exists to provide a consistent and organized way to represent data within our application. Without it, we'd be dealing with unstructured information, making it difficult to process and manage.
Here's a breakdown of the key components of our `Item` model:
*   **`item_id`**: A unique integer that identifies each item. Think of it as a product ID in a store.
*   **`name`**:  A string that describes the item.  This is the human-readable label.
*   **`value`**: A numerical value associated with the item. This could represent a price, a measurement, or any other relevant number.
*   **`processed`**: A boolean (True/False) flag that indicates whether the item has been processed by our application.  It starts as `False` and can be changed to `True`.
Now, let's see how this `Item` model is defined in Python code. We'll use a `dataclass` for this, which provides a convenient way to create classes that primarily hold data.
```python
--- File: models.py ---
"""Data models for Sample Project 2.
Defines the structure of data objects used within the application,
using dataclasses for simplicity and type safety.
"""
from dataclasses import dataclass, field
@dataclass
class Item:
    """Represent a single data item to be processed.
    Attributes:
        item_id (int): A unique integer identifier for the item.
        name (str): The name of the item.
        value (float): A numerical value associated with the item.
        processed (bool): A boolean flag indicating if the item has been
            processed. Defaults to False.
    """
    item_id: int
    name: str
    value: float
    processed: bool = field(default=False)
    def mark_as_processed(self: "Item") -> None:
        """Set the processed flag to True.
        This method updates the item's state to indicate that it has
        undergone processing.
        Returns:
            None: This method does not return any value.
        """
        print(f"Model Item {self.item_id}: Marking '{self.name}' as processed.")
        self.processed = True
    def __str__(self: "Item") -> str:
        """Return a user-friendly string representation of the item.
        Returns:
            str: A string detailing the item's ID, name, value, and
                 processing status.
        """
        status: str = "Processed" if self.processed else "Pending"
        return f"Item(ID={self.item_id}, Name='{self.name}', Value={self.value:.2f}, Status={status})"
# End of tests/sample_project2/models.py
```
This code defines the `Item` dataclass with the attributes we discussed earlier.  The `processed` attribute is initialized to `False` by default using `field(default=False)`. This means that when you create a new `Item` object, it will automatically be marked as not yet processed.
The `mark_as_processed` method allows us to update the `processed` flag to `True` when the item has been processed. The `__str__` method defines how the `Item` object is represented as a string, making it easier to read and debug.
Here's a simple example of how you might use the `Item` data model:
```python
from models import Item
# Create a new Item
my_item = Item(item_id=1, name="Example Item", value=123.45)
print(my_item)  # Output: Item(ID=1, Name='Example Item', Value=123.45, Status=Pending)
# Mark the item as processed
my_item.mark_as_processed()
print(my_item)  # Output: Item(ID=1, Name='Example Item', Value=123.45, Status=Processed)
```
This snippet shows how to create an `Item` instance, print its initial state, mark it as processed, and then print its updated state.
Understanding the `Item` data model is crucial because it forms the foundation for how we handle data throughout our application.  It's used extensively in the [Data Handling](03_data-handling.md) and [Item Processing](04_item-processing.md) chapters.
This concludes our look at this topic.

Next, we will examine [Data Handling](03_data-handling.md).


---

*Generated by [SourceLens AI](https://github.com/darijo2yahoocom/sourceLensAI) using LLM: `gemini` (cloud) - model: `gemini-2.0-flash` | Language Profile: `python`*
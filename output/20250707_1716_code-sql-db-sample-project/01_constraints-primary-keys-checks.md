> Previously, we looked at the [Project Overview](index.md).

# Chapter 1: Constraints (Primary Keys, Checks)
Let's begin exploring this concept. This chapter will cover constraints, specifically primary keys and check constraints, which are essential for maintaining data integrity in our database. They ensure that the data we store is accurate, consistent, and reliable.
**Why Constraints? The Need for Order**
Imagine a library with books scattered randomly, multiple copies of the same book labeled differently, and no system to ensure the books are properly categorized. Finding what you need would be a nightmare, right? Databases are similar. Without rules, data can become inconsistent and unreliable. Constraints are the rules that bring order to our database "library". They prevent invalid or inconsistent data from being entered, ensuring that our database reflects reality accurately.
**Primary Keys: Unique Identifiers**
A primary key is like the unique ID card for each record in a table. It guarantees that each row has a distinct identifier. No two rows can have the same primary key value, and the primary key column cannot contain `NULL` values (empty values). In our project, each table has a primary key:
*   `users`: `user_id`
*   `products`: `product_id`
*   `orders`: `order_id`
*   `order_items`: `order_item_id`
*   `product_reviews`: `review_id`
This ensures we can easily and reliably identify each user, product, order, order item, and product review.
The following SQL statements, found in `schema/02_constraints_and_indexes.sql`, define the primary keys for the tables:
```python
--- File: schema/02_constraints_and_indexes.sql ---
-- Primary Keys
ALTER TABLE users ADD PRIMARY KEY (user_id);
ALTER TABLE products ADD PRIMARY KEY (product_id);
ALTER TABLE orders ADD PRIMARY KEY (order_id);
ALTER TABLE order_items ADD PRIMARY KEY (order_item_id);
ALTER TABLE product_reviews ADD PRIMARY KEY (review_id);
```
These statements use the `ALTER TABLE` command to add a primary key constraint to the specified column.
**Check Constraints: Validating Data**
Check constraints are rules that specify acceptable values for a column. They ensure that data conforms to certain business rules or data quality standards. For example, a product's price should always be positive, and a rating should fall within a specific range.
Here are the check constraints defined in `schema/02_constraints_and_indexes.sql`:
*   `products`: `price > 0` (price must be positive)
*   `products`: `stock_quantity >= 0` (stock quantity cannot be negative)
*   `order_items`: `quantity > 0` (quantity must be positive)
*   `product_reviews`: `rating >= 1 AND rating <= 5` (rating must be between 1 and 5)
If we try to insert data that violates these constraints, the database will reject the operation, preventing invalid data from entering our system.
```python
--- File: schema/02_constraints_and_indexes.sql ---
-- Check Constraints
ALTER TABLE products ADD CONSTRAINT check_price_positive CHECK (price > 0);
ALTER TABLE products ADD CONSTRAINT check_stock_non_negative CHECK (stock_quantity >= 0);
ALTER TABLE order_items ADD CONSTRAINT check_quantity_positive CHECK (quantity > 0);
ALTER TABLE product_reviews ADD CONSTRAINT check_rating_range CHECK (rating >= 1 AND rating <= 5);
```
These statements add check constraints to the tables, enforcing the defined rules.
**Example Scenario**
Imagine you try to add a product with a negative price. Because of the `check_price_positive` constraint, the database will prevent you from doing so:
```sql
-- Attempt to insert invalid data (negative price)
INSERT INTO products (product_id, name, description, price, stock_quantity)
VALUES (6, 'Invalid Product', 'This product should not be added', -10, 100);
```
This SQL statement would result in an error because it violates the `check_price_positive` constraint. This is exactly what we want â€“ the constraint is protecting our data.
**Relationship to Other Concepts**
Constraints are closely related to [Database Tables](01_database-tables.md), as they are defined *on* tables. They also play a crucial role in [Relationships (Foreign Keys)](04_relationships-foreign-keys.md), ensuring data consistency across related tables. For example, foreign keys rely on primary keys in other tables to establish relationships.
This concludes our look at this topic.

> Next, we will examine [Data Seeding](02_data-seeding.md).


---

*Generated by [SourceLens AI](https://github.com/openXFlow/sourceLensAI) using LLM: `gemini` (cloud) - model: `gemini-2.0-flash` | Language Profile: `Python`*